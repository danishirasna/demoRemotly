{"version":3,"sources":["services/auth/ajax.service.ts","stores/user.store.ts","stores/applications.store.ts","stores/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["handeleError","error","status","handleSuccess","data","url","params","a","axios","get","response","body","post","delete","destroy","setAuthToken","token","defaults","headers","common","UserStore","user","users_list","authenticated","makeAutoObservable","this","ajaxService","setUser","localStorage","setItem","removeItem","window","location","href","id","rows","ApplicationsStore","applications","application","key","Store","Login","React","lazy","App","inject","observer","fallback","className","exact","path","component","Component","Boolean","hostname","match","rootStore","jwtToken","decoded","jwtDecode","currentTime","Date","now","exp","e","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.53a95cd0.chunk.js","sourcesContent":["import axios, { AxiosAdapter, AxiosError, AxiosResponse } from \"axios\"\r\nimport { AjaxOutput } from \"../../interfaces/ajax.dto\";\r\n\r\nfunction handeleError(error: AxiosError | unknown): AjaxOutput {\r\n    return { error, status: \"Failed\" }\r\n}\r\nfunction handleSuccess(data: any): AjaxOutput {\r\n    return { data, status: \"Success\" }\r\n}\r\n\r\n\r\nasync function get(url: string, params: string): Promise<AjaxOutput> {\r\n    try {\r\n        const response: AxiosResponse = await axios.get(`${url}${params}`);\r\n        return handleSuccess(response.data)\r\n    }\r\n    catch (error) {\r\n        return handeleError(error)\r\n    }\r\n}\r\n\r\n\r\nasync function post(url: string, body: any): Promise<AjaxOutput> {\r\n    try {\r\n        const response: AxiosResponse = await axios.post(`${url}`, body);\r\n        return handleSuccess(response.data)\r\n    }\r\n    catch (error) {\r\n        return handeleError(error)\r\n    }\r\n}\r\n\r\nasync function destroy(url: string, params: string): Promise<AjaxOutput> {\r\n    try {\r\n        const response: AxiosResponse = await axios.delete(`${url}${params}`);\r\n        return handleSuccess(response.data)\r\n    }\r\n    catch (error) {\r\n        return handeleError(error)\r\n    }\r\n}\r\n\r\n\r\nfunction setAuthToken(token: string) {\r\n    if (token) {\r\n        axios.defaults.headers.common[\"Authorization\"] = token;\r\n    } else {\r\n        delete axios.defaults.headers.common[\"Authorization\"];\r\n    }\r\n}\r\n\r\n\r\nexport default {\r\n    get, post, destroy, setAuthToken\r\n};","import { stat } from \"fs\"\r\nimport jwtDecode from \"jwt-decode\"\r\nimport { UserDTO } from \"../interfaces/user.dto\"\r\nimport { makeAutoObservable } from \"mobx\"\r\nimport { LoginDTO } from \"../interfaces/login.dto\"\r\nimport ajaxService from \"../services/auth/ajax.service\"\r\n\r\nexport class UserStore {\r\n    user = {}\r\n    users_list = []\r\n    authenticated = false\r\n\r\n    constructor() {\r\n        makeAutoObservable(this)\r\n    }\r\n    async login(body: LoginDTO) {\r\n        const { data, status, error } = await ajaxService.post(\"/login\", body)\r\n        if (status == \"Failed\") {\r\n            return false\r\n        }\r\n        this.setUser(data.token.token);\r\n        ajaxService.setAuthToken(data.token.token)\r\n        localStorage.setItem(\"jwtToken\", data.token.token)\r\n        return true\r\n    }\r\n    logout() {\r\n        // this.authenticated = false\r\n        // this.user = {}\r\n        localStorage.removeItem(\"jwtToken\")\r\n        window.location.href = \"/\";\r\n    }\r\n    setUser(user: any) {\r\n        this.user = user;\r\n        this.authenticated = true\r\n    }\r\n\r\n    async GetAllUsers(url: string, id: any) {\r\n        const { data, status, error } = await ajaxService.get(`/user/list/${id}`, url);\r\n        if (status == \"Failed\") {\r\n            return false;\r\n        }\r\n        this.users_list = data.data.rows\r\n        return this.users_list;\r\n    }\r\n\r\n    async UserCreate(body: UserDTO) {\r\n        const { data, status, error } = await ajaxService.post(\"/user/create\", body);\r\n        if (status == \"Failed\") {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    async DeleteUser(url: string, id: any) {\r\n        const { data, status, error } = await ajaxService.destroy(`/user/delete/${id}`, url);\r\n        if (status == \"Failed\") {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}","import { makeAutoObservable } from \"mobx\"\r\nimport { ApplicationDTO } from \"../interfaces/application.dto\"\r\nimport ajaxService from \"../services/auth/ajax.service\"\r\n\r\nexport class ApplicationsStore {\r\n  applications = [] = [];\r\n  application = {};\r\n  key = \"\"\r\n  constructor() {\r\n    makeAutoObservable(this)\r\n  }\r\n  async ApplicationCreate(body: ApplicationDTO) {\r\n    const { data, status, error } = await ajaxService.post(\"/applications/create\", body);\r\n    if (status == \"Failed\") {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  async GetAllApplications(url: string) {\r\n    const { data, status, error } = await ajaxService.get(`/applications_`, url);\r\n    if (status == \"Failed\") {\r\n      return false;\r\n    }\r\n    this.applications = data.data.rows\r\n    return this.applications;\r\n  }\r\n\r\n  async GetAppByID(url: string, id: any) {\r\n    const { data, status, error } = await ajaxService.get(`/applications_list/${id}`, url);\r\n    if (status == \"Failed\") {\r\n      return false;\r\n    }\r\n    this.application = data.data.rows[0]\r\n    return this.application;\r\n\r\n  }\r\n\r\n  async ChangeApiKey(body: ApplicationDTO) {\r\n    this.key = \"\";\r\n    const { data, status, error } = await ajaxService.post(\"/applications/key/change\", body);\r\n    if (status == \"Failed\") {\r\n      return false;\r\n    }\r\n    this.key = data.data.key\r\n    return this.key;\r\n  }\r\n\r\n\r\n\r\n};\r\n","import { UserStore } from \"./user.store\";\r\nimport { ApplicationsStore } from \"./applications.store\";\r\n\r\ninterface IStore {\r\n    UserStore: UserStore\r\n    ApplicationsStore: ApplicationsStore\r\n}\r\n\r\nclass Store implements IStore {\r\n    UserStore: UserStore\r\n    ApplicationsStore: ApplicationsStore\r\n\r\n    constructor() {\r\n        this.UserStore = new UserStore\r\n        this.ApplicationsStore = new ApplicationsStore\r\n    }\r\n}\r\n\r\nexport default Store;","import React, { Suspense } from 'react';\r\nimport './App.css';\r\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\"\r\nimport Store from './stores';\r\nimport { UserStore } from './stores/user.store';\r\nimport PrivateRoute from './helpers/PrivateRoute';\r\nimport { inject, observer } from 'mobx-react';\r\nconst Login = React.lazy(() => import(\"./components/auth/Login\"))\r\n\r\n\r\ninterface IApp {\r\n  Store: Store\r\n}\r\n\r\nconst App = inject(\"Store\")(observer(\r\n  class App extends React.Component<IApp>{\r\n    render() {\r\n      return (\r\n        <Router>\r\n\r\n          <Suspense fallback={<div> Loading .... </div>}>\r\n            <Switch>\r\n\r\n              <div className=\"App\">\r\n                <Route exact path=\"/\" component={Login} />\r\n\r\n              </div>\r\n\r\n            </Switch>\r\n          </Suspense>\r\n        </Router>\r\n      );\r\n    }\r\n\r\n  }\r\n\r\n\r\n))\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n  // [::1] is the IPv6 localhost address.\r\n  window.location.hostname === '[::1]' ||\r\n  // 127.0.0.0/8 are considered localhost for IPv4.\r\n  window.location.hostname.match(\r\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n  )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport Store from './stores';\r\nimport { Provider } from 'mobx-react';\r\nimport jwtDecode from 'jwt-decode';\r\nimport ajaxService from './services/auth/ajax.service';\r\nconst rootStore = new Store()\r\nif(localStorage.jwtToken) {\r\n  try {\r\n    const decoded:any = jwtDecode(localStorage.jwtToken)\r\n\r\n    const currentTime = Date.now()/1000;\r\n    if(decoded.exp < currentTime) {\r\n      localStorage.removeItem(\"jwtToken\")\r\n      window.location.href = \"/\";\r\n    }\r\n    ajaxService.setAuthToken(localStorage.jwtToken)\r\n    rootStore.UserStore.setUser(decoded);\r\n  }\r\n  catch (e) {\r\n    localStorage.removeItem(\"jwtToken\")\r\n    window.location.href = \"/\";\r\n  }\r\n}\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider\r\n    Store = {rootStore}\r\n    >\r\n    <App Store={rootStore} />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}